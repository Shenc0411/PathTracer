// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Ray 
{
	float3 origin;
	float3 direction;
};

struct HitRecord
{
	float3 hitPoint;
	float3 normal;
	float3 albedo;
	float3 emission;
	float distance;
	float material;
	float fuzz;
	float refractiveIndex;
};

struct Sphere 
{
	float3 position;
	float3 albedo;
	float3 emission;
	float radius;
	float material;
	float fuzz;
	float refractiveIndex;
};

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Texture;
StructuredBuffer<float3> _HemisphereSamples;
StructuredBuffer<float3> screenPixelPositions;
StructuredBuffer<Sphere> spheres;
float3 cameraPosition;
float3 ambientLight;
float widthPerPixel;
float heightPerPixel;

float4 _Time;
float _Seed01;
float _R0;
float _R1;
float _R2;

int pixelResolutionX;
int pixelResolutionY;
int numIterations;
int sampleRate;
int numSpheres;

float GradNoise(int2 xy) 
{
	return frac(52.9829189f * frac(0.06711056f*float(xy.x) + 0.00583715f*float(xy.y)));
}

float Noise(int2 uv)
{
	return GradNoise(floor(fmod(uv, 1024)) + _Seed01 * _Time.y);
}

float3 RandomPointInUnitSphere(int2 uv)
{
	float3 p;
	// Should be a loop until a point on unit sphere is found.
	// Then normalize wouldn't be needed.
	p = 2.0 * normalize(float3(Noise(uv * 2000.0f * (1.0f + _R0)) * 2.0f - 0.5f,
		Noise(uv * 2000.0f * (1.0f + _R1)) * 2 - 0.5f,
		Noise(uv * 2000.0f * (1.0f + _R2)) * 2 - 0.5f)) - float3(1.0f, 1.0f, 1.0f);

	p = 2.0 * normalize(float3(_R0, _R1, _R2)) - float3(1.0f, 1.0f, 1.0f);
	p = _HemisphereSamples[(Noise(uv * 2000.0f) * 392901) % 4096];

	return normalize(float3(Noise(uv), Noise(uv), Noise(uv)));
}

float3 RandomInUnitDisk(int2 uv) {
	return RandomPointInUnitSphere(uv);
}

bool RaySphereCollision(Ray ray, out HitRecord hitRecord)
{
	bool hasHit = false;
	hitRecord.distance = 3e+38F;

	for(int i = 0; i < numSpheres; ++i)
	{
		float3 oc = ray.origin - spheres[i].position;
		float a = dot(ray.direction, ray.direction);
		float b = 2.0f * dot(oc, ray.direction);
		float c = dot(oc, oc) - spheres[i].radius * spheres[i].radius;
		float discriminant = b * b - 4.0f * a * c;
		if (discriminant > 0)
		{
			float hitDistance = (-b - sqrt(discriminant)) / (2.0f * a);
			if (hitDistance > 1e-10F && hitDistance < 3e+38F)
			{
				if (!hasHit || hitDistance < hitRecord.distance)
				{
					float3 hitPoint = ray.origin + hitDistance * ray.direction;
					float3 hitNormal = normalize(hitPoint - spheres[i].position);

					hitRecord.hitPoint = hitPoint;
					hitRecord.normal = hitNormal;
					hitRecord.material = spheres[i].material;
					hitRecord.albedo = spheres[i].albedo;
					hitRecord.emission = spheres[i].emission;
					hitRecord.distance = hitDistance;
					hitRecord.fuzz = spheres[i].fuzz;
					hitRecord.refractiveIndex = spheres[i].refractiveIndex;

					hasHit = true;
					continue;
				}
			}

			hitDistance = (-b + sqrt(discriminant)) / (2.0f * a);
			if (hitDistance > 1e-10F && hitDistance < 3e+38F)
			{
				if (!hasHit || hitDistance < hitRecord.distance)
				{
					float3 hitPoint = ray.origin + hitDistance * ray.direction;
					float3 hitNormal = normalize(hitPoint - spheres[i].position);

					hitRecord.hitPoint = hitPoint;
					hitRecord.normal = hitNormal;
					hitRecord.material = spheres[i].material;
					hitRecord.albedo = spheres[i].albedo;
					hitRecord.emission = spheres[i].emission;
					hitRecord.distance = hitDistance;
					hitRecord.fuzz = spheres[i].fuzz;
					hitRecord.refractiveIndex = spheres[i].refractiveIndex;

					hasHit = true;
					continue;
				}
			}
		}
	}

	return hasHit;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	Ray ray;
	ray.origin = cameraPosition;
	HitRecord hitRecord;
	float3 sum;
	float3 emissions[5];
	float3 attenuations[5];
	float3 result = ambientLight;
	int depth = 5 - 1;

	for (int samples = 0; samples < 2; ++samples) {
		float3 offset = float3(widthPerPixel * Noise(_R0 * samples), heightPerPixel * Noise(_R0 * samples), 0);
		ray.direction = normalize(screenPixelPositions[id.x * pixelResolutionY + id.y] + offset - cameraPosition);

		result = ambientLight;
		depth = 5 - 1;

		for (int i = 0; i < 5; ++i)
		{
			attenuations[i] = ambientLight;

			if (RaySphereCollision(ray, hitRecord))
			{

				float3 attenuation;
				float3 scatteredRayDirection;
				bool scatter = false;

				if (hitRecord.material == 1.0f)
				{
					//Lambertian
					float3 target = hitRecord.hitPoint + hitRecord.normal + RandomPointInUnitSphere(id.xy);
					scatteredRayDirection = target - hitRecord.hitPoint;
					attenuation = hitRecord.albedo;
					scatter = true;
				}
				else if (hitRecord.material == 2.0f)
				{
					//Metal
					scatteredRayDirection = ray.direction - 2.0f * dot(ray.direction, hitRecord.normal) * hitRecord.normal
						+ hitRecord.fuzz * RandomPointInUnitSphere(id.xy) * hitRecord.fuzz;
					attenuation = hitRecord.albedo;

					if (dot(scatteredRayDirection, hitRecord.normal) > 0.0f)
					{
						scatter = true;
					}

				}
				else if (hitRecord.material == 3.0f)
				{
					//Refractive
					float3 reflectedDirection = ray.direction - 2.0f * dot(ray.direction, hitRecord.normal) * hitRecord.normal;
					float3 outwardNormal;
					float3 refractedDirection;
					float reflectProbablity = 1.0f;
					float cosine = 0.0f;
					float niOverNt = 0.0f;
					attenuation = float3(1.0f, 1.0f, 1.0f);

					if (dot(ray.direction, hitRecord.normal) > 0.0f)
					{
						outwardNormal = -hitRecord.normal;
						niOverNt = hitRecord.refractiveIndex;
						cosine = hitRecord.refractiveIndex * dot(ray.direction, hitRecord.normal) / length(ray.direction);
					}
					else
					{
						outwardNormal = hitRecord.normal;
						niOverNt = 1.0f / hitRecord.refractiveIndex;
						cosine = -dot(ray.direction, hitRecord.normal) / length(ray.direction);
					}

					float dt = dot(ray.direction, hitRecord.normal);
					float discriminant = 1.0f - niOverNt * niOverNt * (1.0f - dt * dt);


					if (discriminant > 0.0f)
					{
						//Refract
						refractedDirection = niOverNt * (ray.direction - outwardNormal * dt) - outwardNormal * sqrt(discriminant);
						//Schlick Approximation
						float r0 = (1.0f - hitRecord.refractiveIndex) / (1.0f + hitRecord.refractiveIndex);
						r0 = r0 * r0;
						reflectProbablity = r0 + (1 - r0) * pow((1.0f - cosine), 5.0f);
					}

					if (Noise(id.xy) < reflectProbablity)
					{
						scatteredRayDirection = reflectedDirection;
					}
					else
					{
						scatteredRayDirection = refractedDirection;
					}

					scatter = true;
				}

				if (scatter)
				{
					//TDRay scatteredRay = new TDRay(hitRecord.point, scatteredRayDirection, ray.uv);

					ray.origin = hitRecord.hitPoint;
					ray.direction = normalize(scatteredRayDirection);

					emissions[i] = hitRecord.emission;
					attenuations[i] = attenuation;

					//return hitRecord.emission + attenuation * TraceColor(scatteredRay, numBounces + 1);
				}
				else
				{
					depth = i;
					break;
				}

				//return float3.zero;
			}
			else
			{
				depth = i;
				break;
			}
			//return this.ambientLight;
		}

		for (int j = depth; j >= 0; --j)
		{
			result = emissions[j] + result * attenuations[j];
		}

		sum += result;
	}
	
	

	//return result;
	/*Texture[id.xy] = float4((Texture[id.xy].x * numIterations * sampleRate + result.x) / ((numIterations + 1) * sampleRate),
						(Texture[id.xy].y * numIterations * sampleRate + result.y) / ((numIterations + 1) * sampleRate),
						(Texture[id.xy].z * numIterations * sampleRate + result.z) / ((numIterations + 1) * sampleRate), 0.0f);*/
	Texture[id.xy] = float4(sum, 0.0f);
}


