// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Ray 
{
	float3 origin;
	float3 direction;
};

struct HitRecord
{
	float3 hitPoint;
	float3 normal;
	float3 albedo;
	float3 emission;
	float distance;
	float material;
	float fuzz;
	float refractiveIndex;
};

struct Sphere 
{
	float3 position;
	float3 albedo;
	float3 emission;
	float radius;
	float material;
	float fuzz;
	float refractiveIndex;
};

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Texture;
StructuredBuffer<float3> _HemisphereSamples;
StructuredBuffer<float3> screenPixelPositions;
StructuredBuffer<Sphere> spheres;
float3 cameraPosition;
float3 ambientLight;
float widthPerPixel;
float heightPerPixel;

float4 _Time;
float _Seed01;
float _R0;
float _R1;
float _R2;

int pixelResolutionX;
int pixelResolutionY;
int numIterations;
int sampleRate;
int numSpheres;

float GradNoise(float2 xy)
{
	return frac(52.9829189f * frac(0.06711056f*float(xy.x) + 0.00583715f*float(xy.y)));
}

float Noise(float2 uv)
{
	return GradNoise(floor(fmod(uv, 1024)) + _Seed01 * _Time.y);
}

float3 RandomPointInUnitSphere(float2 uv)
{
	float3 p;
	// Should be a loop until a point on unit sphere is found.
	// Then normalize wouldn't be needed.
	p = 2.0 * normalize(float3(Noise(uv * 2000.0f * (1.0f + _R0)) * 2.0f - 0.5f,
		Noise(uv * 2000.0f * (1.0f + _R1)) * 2 - 0.5f,
		Noise(uv * 2000.0f * (1.0f + _R2)) * 2 - 0.5f)) - float3(1.0f, 1.0f, 1.0f);

	p = 2.0 * normalize(float3(_R0, _R1, _R2)) - float3(1.0f, 1.0f, 1.0f);
	p = _HemisphereSamples[(Noise(uv * 2000.0f) * 392901) % 4096];

	return p;
}

float3 RandomInUnitDisk(float2 uv) {
	return RandomPointInUnitSphere(uv);
}

bool RaySphereCollision(Ray ray, out HitRecord hitRecord)
{
	bool hasHit = false;
	hitRecord.distance = 3e+38F;

	for(int i = 0; i < numSpheres; ++i)
	{
		float3 oc = ray.origin - spheres[i].position;
		float a = dot(ray.direction, ray.direction);
		float b = 2.0f * dot(oc, ray.direction);
		float c = dot(oc, oc) - spheres[i].radius * spheres[i].radius;
		float discriminant = b * b - 4.0f * a * c;
		if (discriminant > 0)
		{
			float hitDistance = (-b - sqrt(discriminant)) / (2.0f * a);
			if (hitDistance > 1e-10F && hitDistance < 3e+38F)
			{
				if (!hasHit || hitDistance < hitRecord.distance)
				{
					float3 hitPoint = ray.origin + hitDistance * ray.direction;
					float3 hitNormal = normalize(hitPoint - spheres[i].position);

					hitRecord.hitPoint = hitPoint;
					hitRecord.normal = hitNormal;
					hitRecord.material = spheres[i].material;
					hitRecord.albedo = spheres[i].albedo;
					hitRecord.emission = spheres[i].emission;
					hitRecord.distance = hitDistance;
					hitRecord.fuzz = spheres[i].fuzz;
					hitRecord.refractiveIndex = spheres[i].refractiveIndex;

					hasHit = true;
					continue;
				}
			}

			hitDistance = (-b + sqrt(discriminant)) / (2.0f * a);
			if (hitDistance > 1e-10F && hitDistance < 3e+38F)
			{
				if (!hasHit || hitDistance < hitRecord.distance)
				{
					float3 hitPoint = ray.origin + hitDistance * ray.direction;
					float3 hitNormal = normalize(hitPoint - spheres[i].position);

					hitRecord.hitPoint = hitPoint;
					hitRecord.normal = hitNormal;
					hitRecord.material = spheres[i].material;
					hitRecord.albedo = spheres[i].albedo;
					hitRecord.emission = spheres[i].emission;
					hitRecord.distance = hitDistance;
					hitRecord.fuzz = spheres[i].fuzz;
					hitRecord.refractiveIndex = spheres[i].refractiveIndex;

					hasHit = true;
					continue;
				}
			}
		}
	}

	return hasHit;
}

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	Ray ray;
	ray.origin = cameraPosition;
	HitRecord hitRecord;
	float3 emissions[5];
	float3 attenuations[5];
	float3 result = ambientLight;
	int depth = 5 - 1;

	int z = id.z;
	z ^= (z << 13);
	z ^= (z >> 17);
	z ^= (z << 5);

	float2 uv = float2(id.x + Noise(_R0 * z), id.y + Noise(_R0 * z));
	float3 offset = float3(widthPerPixel * Noise(_R0 * z), heightPerPixel * Noise(_R0 * z), 0);
	ray.direction = normalize(screenPixelPositions[id.x * pixelResolutionY + id.y] + offset - cameraPosition);

	result = ambientLight;
	depth = 5 - 1;

	for (int i = 0; i < 5; ++i)
	{
		int u = i;
		int v = i;
		u ^= (u << 13);
		u ^= (u >> 17);
		u ^= (u << 5);

		v ^= (v << 13);
		v ^= (v >> 17);
		v ^= (v << 5);

		float2 uvShift = float2(u , v);

		attenuations[i] = ambientLight;

		if (RaySphereCollision(ray, hitRecord))
		{

			float3 attenuation;
			float3 scatteredRayDirection;
			bool scatter = false;

			if (hitRecord.material == 1.0f)
			{
				//Lambertian
				float3 target = hitRecord.hitPoint + hitRecord.normal + RandomPointInUnitSphere(uv + uvShift);
				scatteredRayDirection = target - hitRecord.hitPoint;
				attenuation = hitRecord.albedo;
				scatter = true;
			}
			else if (hitRecord.material == 2.0f)
			{
				//Metal
				scatteredRayDirection = ray.direction - 2.0f * dot(ray.direction, hitRecord.normal) * hitRecord.normal
					+ hitRecord.fuzz * RandomPointInUnitSphere(uv + uvShift) * hitRecord.fuzz;
				attenuation = hitRecord.albedo;

				if (dot(scatteredRayDirection, hitRecord.normal) > 0.0f)
				{
					scatter = true;
				}

			}
			else if (hitRecord.material == 3.0f)
			{
				//Refractive
				float3 reflectedDirection = ray.direction - 2.0f * dot(ray.direction, hitRecord.normal) * hitRecord.normal;
				float3 outwardNormal;
				float3 refractedDirection;
				float reflectProbablity = 1.0f;
				float cosine = 0.0f;
				float niOverNt = 0.0f;
				attenuation = float3(1.0f, 1.0f, 1.0f);

				if (dot(ray.direction, hitRecord.normal) > 0.0f)
				{
					outwardNormal = -hitRecord.normal;
					niOverNt = hitRecord.refractiveIndex;
					cosine = hitRecord.refractiveIndex * dot(ray.direction, hitRecord.normal) / length(ray.direction);
				}
				else
				{
					outwardNormal = hitRecord.normal;
					niOverNt = 1.0f / hitRecord.refractiveIndex;
					cosine = -dot(ray.direction, hitRecord.normal) / length(ray.direction);
				}

				float dt = dot(ray.direction, hitRecord.normal);
				float discriminant = 1.0f - niOverNt * niOverNt * (1.0f - dt * dt);


				if (discriminant > 0.0f)
				{
					//Refract
					refractedDirection = niOverNt * (ray.direction - outwardNormal * dt) - outwardNormal * sqrt(discriminant);
					//Schlick Approximation
					float r0 = (1.0f - hitRecord.refractiveIndex) / (1.0f + hitRecord.refractiveIndex);
					r0 = r0 * r0;
					reflectProbablity = r0 + (1 - r0) * pow((1.0f - cosine), 5.0f);
				}

				if (Noise(uv + uvShift) < reflectProbablity)
				{
					scatteredRayDirection = reflectedDirection;
				}
				else
				{
					scatteredRayDirection = refractedDirection;
				}

				scatter = true;
			}

			if (scatter)
			{
				//TDRay scatteredRay = new TDRay(hitRecord.point, scatteredRayDirection, ray.uv);

				ray.origin = hitRecord.hitPoint;
				ray.direction = normalize(scatteredRayDirection);

				emissions[i] = hitRecord.emission;
				attenuations[i] = attenuation;

				//return hitRecord.emission + attenuation * TraceColor(scatteredRay, numBounces + 1);
			}
			else
			{
				depth = i;
				break;
			}

			//return float3.zero;
		}
		else
		{
			depth = i;
			break;
		}
		//return this.ambientLight;
	}

	for (int j = depth; j >= 0; --j)
	{
		result = emissions[j] + result * attenuations[j];
	}

	//return result;
	/*Texture[id.xy] = float4((Texture[id.xy].x * numIterations * sampleRate + result.x) / ((numIterations + 1) * sampleRate),
						(Texture[id.xy].y * numIterations * sampleRate + result.y) / ((numIterations + 1) * sampleRate),
						(Texture[id.xy].z * numIterations * sampleRate + result.z) / ((numIterations + 1) * sampleRate), 0.0f);*/
	Texture[id.xy] += float4(result / sampleRate, 0.0f);
}


